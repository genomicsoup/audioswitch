/**
 * file: audio.rs
 * desc: Functions for enumerating and switching audio devices.
 */
use crate::policyconfig;
use crate::utility::pwstr_to_string;

use windows::core::{HRESULT, PCWSTR, PWSTR};
use windows::Win32::Devices::FunctionDiscovery::PKEY_Device_FriendlyName;
use windows::Win32::Media::Audio::{
    eAll, eConsole, IMMDevice, IMMDeviceEnumerator, MMDeviceEnumerator, DEVICE_STATE_ACTIVE,
};
use windows::Win32::System::Com::StructuredStorage::STGM_READ;
use windows::Win32::System::Com::{CoCreateInstance, CLSCTX_ALL};
use windows::Win32::UI::Shell::PropertiesSystem::IPropertyStore;

/*
 * STRUCTS
 */

/*
 * Represents an available Windows audio device.
 *
 * fields
 *  id:   unique device ID generated by Windows. Looks something
 *        like {0.0.0.00000000}.{4e08256a-eb68-4f08-b890-0e384cd975a6}
 *  name: human-readable device name, returned using the PKEY_Device_FriendlyName
 *        property key.
 */
#[derive(Clone)]
pub struct AudioDevice {
    pub id: String,
    pub name: String,
}

/*
 * Represents a collection of available Windows audio devices.
 *
 * fields
 *  devices: a list of AudioDevices
 */
pub struct AudioDeviceCollection {
    pub devices: Vec<AudioDevice>,
}

/*
 * IMPLEMENTATIONS
 */

impl std::fmt::Display for AudioDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "<AudioDevice id: {} name: {}>", self.id, self.name)
    }
}

impl AudioDevice {
    /**
     * Generates a new AudioDevice. The Windows API to retrieve audio devices always returns
     * pointers to wide strings, we convert them here into Rust strings.
     *
     * args
     *  id:   unique device ID
     *  name: human readable device name
     */
    pub fn new(id: PWSTR, name: PWSTR) -> Self {
        AudioDevice {
            id: unsafe { pwstr_to_string(id) },
            name: unsafe { pwstr_to_string(name) },
        }
    }

    /**
     * Convert the AudioDevice ID into a wide string that can be used with the Windows API.
     *
     * returns
     *  audio device ID as a wide string
     */
    pub fn id_as_wide(self) -> Vec<u16> {
        self.id.encode_utf16().collect::<Vec<u16>>()
    }

    /**
     * Change the currently used audio device to this one.
     *
     * returns
     *  a boolean indicating if the change was successful
     */
    pub fn change_audio_device(self) -> Result<(), String> {
        // Generate an interface to PolicyConfig
        let policy_wrapper: Result<policyconfig::IPolicyConfig, windows::core::Error> =
            unsafe { CoCreateInstance(&policyconfig::PolicyConfig, None, CLSCTX_ALL) };

        if policy_wrapper.is_err() {
            return Err(format!(
                "Failed to grab IPolicyConfig: '{:?}'",
                policy_wrapper.err()
            ));
        }

        let policy_config = policy_wrapper.unwrap();
        let mut wide_id = self.id_as_wide();

        // Switch audio devices
        let set_result =
            unsafe { policy_config.SetDefaultEndpoint(&PCWSTR(wide_id.as_mut_ptr()), eConsole) };

        // I think this function always returns an error. Even on success, it returns an error
        // code 0x0 indicating the operation completed successfully
        if set_result.is_err() {
            // Check the error to see if it's actually a success
            let error = set_result.err().unwrap();

            if error.code() == HRESULT(0) {
                return Ok(());
            }

            return Err(format!("Failed to set default device: '{:?}'", error));
        }

        Ok(())
    }
}

impl Default for AudioDeviceCollection {
    /**
     * Default constructor and initialization for the AudioDeviceCollection struct.
     * The Windows COM API must be initialized prior to initializing a collection of
     * audio devices or the program will panic.
     */
    fn default() -> Self {
        // Grabs a device enumerator so we can query audio devices
        let enumerator_result: Result<IMMDeviceEnumerator, windows::core::Error> =
            unsafe { CoCreateInstance(&MMDeviceEnumerator, None, CLSCTX_ALL) };

        if enumerator_result.is_err() {
            panic!(
                "Failed to grab IMMDeviceEnumerator '{:?}'",
                enumerator_result.err()
            );
        }

        // Use the device enumerator to enumerate active audio devices, the collection will contain
        // individual IMMDevices.
        let device_enumerator = enumerator_result.unwrap();
        let collection_result =
            unsafe { device_enumerator.EnumAudioEndpoints(eAll, DEVICE_STATE_ACTIVE) };

        if collection_result.is_err() {
            panic!(
                "Failed to grab IMMDeviceCollection: '{:?}'",
                collection_result.err()
            );
        }

        // Get the actual collection
        let device_collection = collection_result.unwrap();
        let mut devices: Vec<AudioDevice> = Vec::new();

        unsafe {
            for i in 0..device_collection.GetCount().unwrap() {
                // Grab an individual device (IMMDevice) and also its property store
                let immdevice: IMMDevice = device_collection.Item(i).unwrap();
                let device_properties: IPropertyStore =
                    immdevice.OpenPropertyStore(STGM_READ).unwrap();

                // This is the unique device ID
                let dev_id = immdevice.GetId().unwrap();
                // This is the human readable device name stored in a PROPVARIANT
                let device_name_prop = device_properties
                    .GetValue(&PKEY_Device_FriendlyName)
                    .unwrap();

                // lol this propvariant struct is fucking gross
                devices.push(AudioDevice::new(
                    dev_id,
                    device_name_prop.Anonymous.Anonymous.Anonymous.pwszVal,
                ));
            }
        }

        AudioDeviceCollection { devices }
    }
}
